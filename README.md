# The DVFS Hurryup Cloud Scheduler
## What is it?
DVFS Hurryup is a proof-of-concept of a scheduling methodology. As such, It's sole purpose is to speedup applications (usually, request-related applications), maintaining a target quality-of-service while also reducing energy consumption.

It currently works only with Xapian (search) and (soon) Sphinx (caching), both applications from the Tailbench suite[1].

## Overview: how does it works?
DVFS Hurryup assumes that the application has an established hot function which is responsible for a great amount of a request's  execution time (due to processing; IO operations are excluded). Most requests (associated to a thread in a processor core) known as 'light requests' will execute that hot function within the desired time, while others (the 'heavy requests') will take too much time and possibly violate the quality of service metric - in the latter case, DVFS Hurryup will elevate the operating frequency within the processor core where the thread is executing and then, after the execution of the hot function, it comes back to the base frequency. 

### Technical info
As there are technological barriers to this concept, Hurryup uses intra-instrumentation to detect the activation of the hot function instead of profiling tools, as the associated overhead is usually heavy for a request span of few miliseconds. Also, it utilizes hardcoded functions to access the model-specific registers for core frequency in order to avoid the overhead introduced by the operating system interface (e.g.: Linux's cpufreq). 

## Requisites
* Processor with dynamic voltage/frequency scaling (e.g.: Intel Skylake and above);
* Linux 5.0 with acpi driver activated (as it allows the writing direct to the model-specific register in order to avoid overheads);
* Datasets for tailbench software

## Git structure
This repository is composed of the following folders:
* **aux**: Contains eventual scripts to access model-specific registers, scripts to visualize graphics (in Julia) and to install eventual dependencies. 
* **bin**: Containes precompiled code of Hurryup for Skylake processors, and also the source code.
* **docs**: Articles, presentations, thesis, etc.
* **graphs**: Illustrated graphs of some results.
* **old-java**: From the previous iteration of Hurryup, where Elasticsearch was utilized.
* **raw-results**: Usually the lats.bin file generated by the Tailbench suite. Refer to each the Readme of each individual directory.

## References
* [1] KASTURE, H. SANCHEZ, D. TailBench: A Benchmark Suite and Evaluation Methodology for Latency-Critical Applications. In: Proceedings of the 2016 IEEE International Symposium on Workload Characterization (IISWC). 2016.
